// Code generated by protoc-gen-go.
// source: agent_api.proto
// DO NOT EDIT!

/*
Package api is a generated protocol buffer package.

It is generated from these files:
	agent_api.proto

It has these top-level messages:
	Request
	Reply
	Bridges
	Vxlan
	Subnets
*/
package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Request_Module int32

const (
	Request_OVS_BRIDGES Request_Module = 0
	Request_VXLAN       Request_Module = 1
	Request_SUBNETS     Request_Module = 2
)

var Request_Module_name = map[int32]string{
	0: "OVS_BRIDGES",
	1: "VXLAN",
	2: "SUBNETS",
}
var Request_Module_value = map[string]int32{
	"OVS_BRIDGES": 0,
	"VXLAN":       1,
	"SUBNETS":     2,
}

func (x Request_Module) String() string {
	return proto.EnumName(Request_Module_name, int32(x))
}

type Request struct {
	// Types that are valid to be assigned to State:
	//	*Request_Bridges
	//	*Request_Vxlan
	//	*Request_Subnets
	State isRequest_State `protobuf_oneof:"state"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}

type isRequest_State interface {
	isRequest_State()
}

type Request_Bridges struct {
	Bridges *Bridges `protobuf:"bytes,1,opt,name=bridges,oneof"`
}
type Request_Vxlan struct {
	Vxlan *Vxlan `protobuf:"bytes,2,opt,name=vxlan,oneof"`
}
type Request_Subnets struct {
	Subnets *Subnets `protobuf:"bytes,3,opt,name=subnets,oneof"`
}

func (*Request_Bridges) isRequest_State() {}
func (*Request_Vxlan) isRequest_State()   {}
func (*Request_Subnets) isRequest_State() {}

func (m *Request) GetState() isRequest_State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *Request) GetBridges() *Bridges {
	if x, ok := m.GetState().(*Request_Bridges); ok {
		return x.Bridges
	}
	return nil
}

func (m *Request) GetVxlan() *Vxlan {
	if x, ok := m.GetState().(*Request_Vxlan); ok {
		return x.Vxlan
	}
	return nil
}

func (m *Request) GetSubnets() *Subnets {
	if x, ok := m.GetState().(*Request_Subnets); ok {
		return x.Subnets
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Request) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _Request_OneofMarshaler, _Request_OneofUnmarshaler, []interface{}{
		(*Request_Bridges)(nil),
		(*Request_Vxlan)(nil),
		(*Request_Subnets)(nil),
	}
}

func _Request_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Request)
	// state
	switch x := m.State.(type) {
	case *Request_Bridges:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Bridges); err != nil {
			return err
		}
	case *Request_Vxlan:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Vxlan); err != nil {
			return err
		}
	case *Request_Subnets:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Subnets); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Request.State has unexpected type %T", x)
	}
	return nil
}

func _Request_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Request)
	switch tag {
	case 1: // state.bridges
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Bridges)
		err := b.DecodeMessage(msg)
		m.State = &Request_Bridges{msg}
		return true, err
	case 2: // state.vxlan
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Vxlan)
		err := b.DecodeMessage(msg)
		m.State = &Request_Vxlan{msg}
		return true, err
	case 3: // state.subnets
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Subnets)
		err := b.DecodeMessage(msg)
		m.State = &Request_Subnets{msg}
		return true, err
	default:
		return false, nil
	}
}

type Reply struct {
	Result     int32  `protobuf:"varint,1,opt,name=result" json:"result,omitempty"`
	LogMessage string `protobuf:"bytes,2,opt,name=log_message" json:"log_message,omitempty"`
}

func (m *Reply) Reset()         { *m = Reply{} }
func (m *Reply) String() string { return proto.CompactTextString(m) }
func (*Reply) ProtoMessage()    {}

type Bridges struct {
	Dummy string `protobuf:"bytes,1,opt,name=dummy" json:"dummy,omitempty"`
}

func (m *Bridges) Reset()         { *m = Bridges{} }
func (m *Bridges) String() string { return proto.CompactTextString(m) }
func (*Bridges) ProtoMessage()    {}

type Vxlan struct {
	Dummy string `protobuf:"bytes,1,opt,name=dummy" json:"dummy,omitempty"`
}

func (m *Vxlan) Reset()         { *m = Vxlan{} }
func (m *Vxlan) String() string { return proto.CompactTextString(m) }
func (*Vxlan) ProtoMessage()    {}

type Subnets struct {
	Dummy string `protobuf:"bytes,1,opt,name=dummy" json:"dummy,omitempty"`
}

func (m *Subnets) Reset()         { *m = Subnets{} }
func (m *Subnets) String() string { return proto.CompactTextString(m) }
func (*Subnets) ProtoMessage()    {}

func init() {
	proto.RegisterEnum("api.Request_Module", Request_Module_name, Request_Module_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for NlanAgent service

type NlanAgentClient interface {
	Add(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Reply, error)
	Update(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Reply, error)
	Delete(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Reply, error)
}

type nlanAgentClient struct {
	cc *grpc.ClientConn
}

func NewNlanAgentClient(cc *grpc.ClientConn) NlanAgentClient {
	return &nlanAgentClient{cc}
}

func (c *nlanAgentClient) Add(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := grpc.Invoke(ctx, "/api.NlanAgent/Add", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nlanAgentClient) Update(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := grpc.Invoke(ctx, "/api.NlanAgent/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nlanAgentClient) Delete(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := grpc.Invoke(ctx, "/api.NlanAgent/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NlanAgent service

type NlanAgentServer interface {
	Add(context.Context, *Request) (*Reply, error)
	Update(context.Context, *Request) (*Reply, error)
	Delete(context.Context, *Request) (*Reply, error)
}

func RegisterNlanAgentServer(s *grpc.Server, srv NlanAgentServer) {
	s.RegisterService(&_NlanAgent_serviceDesc, srv)
}

func _NlanAgent_Add_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Request)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(NlanAgentServer).Add(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _NlanAgent_Update_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Request)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(NlanAgentServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _NlanAgent_Delete_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Request)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(NlanAgentServer).Delete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _NlanAgent_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.NlanAgent",
	HandlerType: (*NlanAgentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _NlanAgent_Add_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _NlanAgent_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _NlanAgent_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
